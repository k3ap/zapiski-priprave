\naslov{Osnovna struktura pogojnega stavka}

Pogosto želimo, da računalnik izvaja drugačno kodo glede na vrednost ene ali
več spremenljivk, npr.~da nam pokaže drugačno vsebino, če smo napisali
pravilno ali napačno geslo, da računalo sešteva, če smo pritisnili gumb za
seštevanje, oz.~odšteva, če smo pritisnili gumb za odštevanje.
Z drugimi besedami, želimo upravljati potek programa (torej izbrati, katera koda
naj se izvede) glede na vrednosti spremenljivk.
Angleško takemu upravljanju pravimo \emph{control flow}, najpogosteje pa ga
izvajamo s t.i.~\emph{pogojnimi stavki}.
Osnovna struktura je sledeča:

\fkoda{poglavja/pogojni-stavki/sintaksa.cpp}

\emph{Pogoj} je nov pojem. Označuje neke vrste račun, katerega rezultat ni
število, vendar \emph{logična vrednost}.
Tu sta možni vrednosti le dve: pravilno (angl.~\koda{true}) in napačno
(angl.~\koda{false}).
Če bo rezultat računa, navedenega v običajnih oklepajih v zgornjem \koda{if}
stavku, \koda{true}, se bo izvedla koda znotraj prvih zavitih oklepajev, če pa
je rezultat računa \koda{false}, pa se bo izvedla koda v drugih zavitih
oklepajih (tistih za besedo \koda{else}).
Drugega dela, tj.~\koda{else} in oklepaje za njim, ni treba pisati, če tega ne
želimo.

Kako pa zapišemo pogoj?
Za to uporabimo posebne \emph{logične operatorje}.
Pri delu s številkami so nam na voljo naslednji:
\begin{itemize}
\item \koda{==}: primerja dve številski vrednosti.
  Rezultat je \koda{true}, če sta vrednosti enaki.
\item \koda{!=}: primerja dve številski vrednosti.
  Rezultat je \koda{true}, če sta vrednosti različni.
\item \koda{<}: primerja dve številski vrednosti.
  Rezultat je \koda{true}, če je vrednost na levi manjša od vrednosti na desni.
\item \koda{>}: deluje podobno kot \koda{<}, le da v drugo smer;
  rezultat je \koda{true}, če je vrednost na desni manjša od vrednosti na levi.
\item \koda{<=}: primerja dve številski vrednosti.
  Rezultat je \koda{true}, če sta vrednosti enaki, ali če je vrednost
  na levi manjša od vrednosti na desni.
\item \koda{>=} deluje podobno kot \koda{<=}, le da v drugo smer.
\end{itemize}

Poglejmo si primer uporabe pogojnega stavka.

\fkoda{poglavja/pogojni-stavki/stevila.cpp}

Program v zgornjem primeru primerja dve števili z vsemi naštetimi operatorji.
Če v program vpišemo npr.~števili $3$ in $7$, vstopimo v drugi, tretji in peti
pogojni stavek, zaradi česar se izpišejo naslednje vrstice:
%
\begin{verbatim}
Stevili sta razlicni.
Prvo stevilo je manjse od drugega.
Prvo stevilo je manjse ali enako drugemu.
\end{verbatim}
%
Če pa v program dvakrat vnesemo število $12$ (ali katerokoli drugo število), pa
dobimo naslednji izhod:
%
\begin{verbatim}
Stevili sta enaki.
Prvo stevilo je manjse ali enako drugemu.
Prvo stevilo je vecje ali enako drugemu.
\end{verbatim}

Pozorni moramo biti, da pri primerjavi enakosti dveh števil napišemo dva
enačaja, \koda{==}.
Če zapišemo le en enačaj, kot v matematiki (torej \koda{=}), se bo program sicer
zagnal, vendar ne bo deloval pravilno.
Enojnega enačaja nikoli ne uporabljamo v pogoju \koda{if} stavka!

Oglejmo si še primer uporabe stavka \koda{else}.
Spodnji program bo uporabnika vprašal za PIN, in mu napisal, če je bil PIN
pravilen oziroma napačen.

\fkoda{poglavja/pogojni-stavki/pin.cpp}

Pogojne stavke lahko tudi gnezdimo, torej vstavimo enega v drugega.
Spodnji program od uporabnika sprejme naročilo v restavraciji, kjer ponujajo
dve vrsti hrane; juhe in sendviče.
Na voljo sta dve vrsti juhe, in dve vrsti sendvičev.
Za izbiro kosila uporabnik prvo izbere med juho in sendvičem, nato pa še okus.

\fkoda{poglavja/pogojni-stavki/nesting.cpp}

Pozorni bodimo na postavitev kode.
Običajno kodo znotraj zavitih oklepajev \koda{if} stavka pišemo tako, da je
poravnana štiri presledke bolj desno od kode zunaj \koda{if} stavka.
V nekaterih programskih jezikih je taka poravnava obvezna, v C/C++ pa ne, vendar
nezamaknjena koda že v majhnih programih postane popolnoma nepregledna.
Branje in popravljanje kode je veliko lažje, če del kode znotraj zavitih
oklepajev zamaknemo za štiri presledke.
Za to lahko uporabimo tudi tipko Tab, ki se na tipkovnici nahaja levo od tipke
Q.
Kode kot spodaj nikoli ne pišemo!

\fkoda{poglavja/pogojni-stavki/unindented.cpp}

\poglavje{Nizanje pogojev}

Pogosto se srečamo s problemi, kjer je za rešitev potrebno upoštevati več kot
en pogoj.
V takih primerih želimo združiti več pogojnih stavkov tako, da se nek del kode
izvede, če velja prvi pogoj, drugi del kode pa, če prvi pogoj ne velja, velja pa
drugi pogoj.
Z gnezdenjem stavkov lahko to v kodo vključimo na naslednji način:

\fkoda{poglavja/pogojni-stavki/nizanje-narobe.cpp}

V takem primeru nam je na voljo bližnjica \koda{else if}.
Zgornja koda deluje popolnoma enako kot spodnja:

\fkoda{poglavja/pogojni-stavki/nizanje-pravilno.cpp}

Prednost te bližnjice je, da je naša koda krajša in bolj razumljiva.
Stavke \koda{else if} lahko tudi verižimo; enemu \koda{if} stavku lahko sledi
poljubno mnogo stavkov \koda{else if}.
Pri tem bo računalnik pogoje preverjal po vrsti.
Pri prvem veljavnem pogoju se bo ustavil in izvedel kodo v pripadajočih zavitih
oklepajih, za čimer ne bo več preverjal pogojev, temveč bo izvajanje nadaljeval
za zaključkom vseh nanizanih stavkov.
Kakor nam v osnovnem \koda{if} stavku ni bilo treba pisati dela z \koda{else},
če ga nismo potrebovali, nam ga tudi pri uporabi \koda{else if} ni treba.

Oglejmo si primer uporabe.
Naslednji program prebere število in pove, če je večje, manjše ali enako 0.

\fkoda{poglavja/pogojni-stavki/vecje-manjse-enako.cpp}

Naslednji primer prikaže, da se izvede samo koda pri prvem veljavnem pogoju, ne
glede na to, koliko pogojev za tem je tudi veljavnih.
Program izpiše le eno vrstico besedila --- \verb+a je 7+, kljub temu, da velja
tudi \koda{a > 1}.

\fkoda{poglavja/pogojni-stavki/nizanje-elseif.cpp}

\naslov{Logični vezniki}

Osnovni operatorji za primerjavo pogosto niso dovolj, da izrazimo željen pogoj.
Če na primer želimo pogledati, ali je neko število med dvema drugima, tega ne
moramo narediti samo z eno primerjavo.
Pogoje združujemo s t.i. \emph{logičnimi vezniki}, ki jim včasih pravimo tudi
\emph{logični operatorji}.
Poznamo tri osnovne veznike:
\begin{itemize}
\item \koda{and} oz.~\koda{&&} združi dva pogoja tako, da združeni pogoj velja
  samo v primeru, da veljata oba hkrati.
\item \koda{or} oz.~\koda{||} združi dva pogoja tako, da združeni pogoj velja
  v primeru, da velja katerikoli od dveh, ali da veljata oba.
\item \koda{not} oz.~\koda{!} sprejme samo en pogoj.
  Nov pogoj velja samo takrat, ko originalni pogoj ne velja.
\end{itemize}

Poglejmo si enostaven primer.
Če želimo preveriti, ali je dano število med dvema drugima, uporabimo
logični veznik \koda{&&}.

\fkoda{poglavja/pogojni-stavki/med-steviloma.cpp}

V matematiki pogosto napišemo dvojno primerjavo $a < b < c$.
Če nekaj podobnega napišemo v C++ program, se bo le-ta sicer zagnal, vendar
ne bo deloval pravilno.
Kaj pričakujemo, da se zgodi, če v tako primerjavo zapišemo \verb+3 < 2 < 1+?
Preveri, kaj se dejansko zgodi!

Pri kombiniranju pogojev bodimo previdni glede pravil prednosti.
Zanikanje (veznik \koda{not} oz.~\koda{!}) ima namreč prednost pred primerjalnimi
vezniki (\koda{<}, \koda{==}, \ldots), ter drugima ločnima veznikoma.
Če v takem primeru uporabljamo zanikanje, moramo zanikan izraz postaviti
v oklepaje.

Za konec si oglejmo še malo bolj kompleksen primer.
Napišimo program, ki preveri, ali je uporabnik vpisal prestopno leto.
Leto je prestopno, če je deljivo s $4$, razen če je hkrati deljivo s $100$.
Izjema so leta, deljiva s 400, ki so prestopna kljub temu, da so deljiva s
$100$.

Kako te pogoje zapišemo v program?
Opazimo, da so leta, deljiva s $400$, prestopna ne glede na druga pogoja.
Če leto ni deljivo s $400$, potem mora biti deljivo s $4$ in ne sme biti deljivo s
$100$.
Povedano krajše, leto mora biti deljivo s $400$, ali pa s $4$ in ne hkrati s
$100$.
Tak pogoj lahko zapišemo z logičnimi vezniki.

\fkoda{poglavja/pogojni-stavki/prestopno-leto.cpp}

% LocalWords:  nezamaknjena
